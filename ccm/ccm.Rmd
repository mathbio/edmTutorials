---
title: "Convergent Cross Mapping (CCM)"
subtitle: "School on Physics Applications in Biology, January 2018"
author: "Brenno Cabella, Roberto Kraenkel, Renato Coutinho, Paulo Inácio Prado, Rafael Lopes"
date: "`r format(Sys.time(), '%d de %B de %Y')`"
output:
         rmdformats::readthedown:
         self_contained: true
         thumbnails: true
         lightbox: true
         gallery: false
         highlight: tango
         toc_depth: 4
---

```{r setup, echo=FALSE, warning=FALSE, message=F}
library(knitr)#; library(zoo); library(xts)
library(plotly)
library(rEDM)
library(ggplot2)#; library(cowplot)
library(dplyr); library(tidyr)


opts_chunk$set(fig.align = 'center',
               fig.show = 'hold',
               fig.height = 5,
               warning = FALSE, message = FALSE, error = FALSE, echo=FALSE)
options(formatR.arrow = TRUE,width = 90)###, cache=TRUE)
```

This tutorial starts by presenting the general idea of Convergent Cross Mapping (Ye *et al.* 2017), next it shows some applied examples using syntetic data.
In the last section a real data analysis is proposed as an exercise.
For these activities, you will need the most recent version of [R](https://cran.r-project.org/) and the rEDM package installed in your working computer.

Before you proceed,
please read carefully the introduction and the first section (*"Empirical Dynamic Modelling"*) of
rEDM's tutorial that you can find [here](https://cran.r-project.org/web/packages/rEDM/vignettes/rEDM-tutorial.html) 
or in your local R installation with the command

```{r call vignette, echo=TRUE, eval=FALSE}
vignette("rEDM-tutorial", package="rEDM")
```

# Convergent Cross Mapping: From Chaos to Chaos-ality

## Syntetic Data

First, We will need to simulate a deterministic discrete-time dynamics with chaotic behavior.
To create a time series from this dynamics with 150 time steps run the commands below in the R console:

```{r generate data, echo=TRUE}

## Two vectors to store data
X <- c()
Y <- c()
## Initial values
X[1] <- 0.1
Y[1] <- 0.1
## Iterate the dynamics 150 time steps
for(i in 2:150){
  X[i] <- 3.77*X[i-1]*(1-X[i-1])
  Y[i] <- 3.82*Y[i-1]*(1-Y[i-1]-0.05*X[i-1])
}
XY<-as.data.frame(cbind(X,Y))
  
```

Here we have the time series of two coupled species in a chaotic regime.
In this first example the variable X is causing changes in Y.
However, populations do not seem to be related.

```{r plot 1st time series}
par(cex=1.1,lwd=2)
  plot(20:50,X[20:50],type="b", pch=18, col="blue",ylim=c(min(X,Y),max(X,Y)),main='Two Species',xlab = 'time',ylab='Population')
  lines(20:50,Y[20:50],pch=19, col="red", type="b",lty=2,lwd=2)
  legend(x = "bottomright", legend = c("X", "Y"),lty=c(1,2),pch=c(18,19) ,col = c("blue", "red"), inset = 0.02,lwd=2)
  # save data for future use
  write.csv(XY, file = "data_unidirectional.csv",row.names=F)
  
  
```

The correlation coeficient between X and Y can becalculated and it is shown in the figure below.
```{r plot correlation}
fit<-lm(Y ~ X)
plot(X,Y,main='Correlation (X,Y)')
abline(fit$coefficients[1],fit$coefficients[2])
legend(x = "bottomleft", legend = paste('r =',round(cor(X,Y)*100)/100),inset = 0.02,col = 'black',lty = 1)

```

Although the data comes from a model with is causality, X and Y are not correlated. Lack of correlation does not imply lack of causation.

## Cross Mapping

What to do next? How can I extract this information from the coupled dynamics?
As we have seen in a previous section, a generic property of lagged-coordinate embedding is that points x(t) on MX map 1:1 to points m(t) on M and local neighborhoods on MX map to local neighborhoods on M (19, 20). 
It follows that for two variables X and Y that are dynamically coupled, local neighborhoods on their respective lagged reconstructions, MX and MY, will map to each other (3, 8, 19, 20, 24, 27, 35,37-42) since X and Y are essentially alternative observations of the common attractor manifold M.

Convergent cross mapping determines how well local neighborhoods on MX
correspond to local neighborhoods on MY and vice versa. 
To do so, a manifold MX is constructed from lags of variable X and used to estimate contemporaneous values of Y. 
Similarly, a manifold MY is constructed from lags of variable Y and used to estimate contemporaneous values of X.

To do so, we first need to obtain the optimal embedding dimension for both variables using the simplex function.

```{r optimal embeddings}
options(warn = -1)
E_star_X<-which.max(simplex(X,silent=T)$rho)
print(paste('E*(X) =',E_star_X))

E_star_Y<-which.max(simplex(Y,silent=T)$rho)
print(paste('E*(Y) =',E_star_Y))

```

Now that we have the optimal embeddings, we can construct the lagged-coordinates MX and MY using the make_block from rEDM package.

Shadow maninfold MX and 3 nearest neighbors from focal point.
```{r MX X_xmap_Y}

Shadow_MXY<-make_block(XY,max_lag = 2)
Shadow_MX<-Shadow_MXY[,2:3]
Shadow_MY<-Shadow_MXY[,4:5]
focal_point<-50
dist.matrix_X <- as.matrix(dist(Shadow_MX, upper=TRUE))
dist.matrix_Y <- as.matrix(dist(Shadow_MY, upper=TRUE))
neigb_X <- order(dist.matrix_X[focal_point,])[2:4]
neigb_Y <- order(dist.matrix_Y[focal_point,])[2:4]
color=rgb(0,0,0,alpha=0.1)
plot(Shadow_MX[,2],Shadow_MX[,1],col = color, pch=16,main='MX',xlab='x(t)',ylab='x(t+1)')
points(Shadow_MX[focal_point,2],Shadow_MX[focal_point,1],col='red',cex=2.5, pch = 1, lwd = 4)
points(Shadow_MX[neigb_X[1],2],Shadow_MX[neigb_X[1],1],pch=16,col='blue')
points(Shadow_MX[neigb_X[2],2],Shadow_MX[neigb_X[2],1],pch=16,col='blue')
points(Shadow_MX[neigb_X[3],2],Shadow_MX[neigb_X[3],1],pch=16,col='blue')

plot(Shadow_MX[,2],Shadow_MX[,1],col = color, pch=16,xlim=c(Shadow_MX[focal_point,2]-0.05,Shadow_MX[focal_point,2]+0.05),ylim=c(Shadow_MX[focal_point,1]-0.1,Shadow_MX[focal_point,1]+0.1),main='MX (Zoom in)',xlab='x(t)',ylab='x(t+1)')
points(Shadow_MX[focal_point,2],Shadow_MX[focal_point,1],pch=16,col='red',cex=1.5)
points(Shadow_MX[neigb_X[1],2],Shadow_MX[neigb_X[1],1],pch=16,col='blue',cex=1.5)
points(Shadow_MX[neigb_X[2],2],Shadow_MX[neigb_X[2],1],pch=16,col='blue',cex=1.5)
points(Shadow_MX[neigb_X[3],2],Shadow_MX[neigb_X[3],1],pch=16,col='blue',cex=1.5)



```
Shadow maninfold MY and contemporary nearest neighbors from focal point.
```{r MY X_xmap_Y}
plot(Shadow_MY[,2],Shadow_MY[,1],col = color, pch=16,main='MY',xlab='y(t)',ylab='y(t+1)')
points(Shadow_MY[focal_point,2],Shadow_MY[focal_point,1],pch=16,col='red')
points(Shadow_MY[neigb_X[1],2],Shadow_MY[neigb_X[1],1],pch=16,col='blue')
points(Shadow_MY[neigb_X[2],2],Shadow_MY[neigb_X[2],1],pch=16,col='blue')
points(Shadow_MY[neigb_X[3],2],Shadow_MY[neigb_X[3],1],pch=16,col='blue')
```
Shadow Maninfold MY and 3 nearest neighbors from focal point.

```{r MY - Y_xmap_X}

color=rgb(0,0,0,alpha=0.1)
plot(Shadow_MY[,2],Shadow_MY[,1],col = color, pch=16,main='MX',xlab='x(t)',ylab='x(t+1)')
points(Shadow_MY[focal_point,2],Shadow_MY[focal_point,1],col='red',cex=2.5, pch = 1, lwd = 4)
points(Shadow_MY[neigb_Y[1],2],Shadow_MY[neigb_Y[1],1],pch=16,col='blue')
points(Shadow_MY[neigb_Y[2],2],Shadow_MY[neigb_Y[2],1],pch=16,col='blue')
points(Shadow_MY[neigb_Y[3],2],Shadow_MY[neigb_Y[3],1],pch=16,col='blue')

plot(Shadow_MY[,2],Shadow_MY[,1],col = color, pch=16,xlim=c(Shadow_MY[focal_point,2]-0.1,Shadow_MY[focal_point,2]+0.1),ylim=c(Shadow_MY[focal_point,1]-0.1,Shadow_MY[focal_point,1]+0.1),main='MY (Zoom in)',xlab='x(t)',ylab='x(t+1)')
points(Shadow_MY[focal_point,2],Shadow_MY[focal_point,1],pch=16,col='red',cex=1.5)
points(Shadow_MY[neigb_Y[1],2],Shadow_MY[neigb_Y[1],1],pch=16,col='blue',cex=1.5)
points(Shadow_MY[neigb_Y[2],2],Shadow_MY[neigb_Y[2],1],pch=16,col='blue',cex=1.5)
points(Shadow_MY[neigb_Y[3],2],Shadow_MY[neigb_Y[3],1],pch=16,col='blue',cex=1.5)



```
Shadow maninfold MX and contemporary nearest neighbors from focal point.

```{r MX Y_xmap_X}
plot(Shadow_MX[,2],Shadow_MX[,1],col = color, pch=16,main='MX',xlab='y(t)',ylab='y(t+1)')
points(Shadow_MX[focal_point,2],Shadow_MX[focal_point,1],pch=16,col='red')
points(Shadow_MX[neigb_Y[1],2],Shadow_MX[neigb_Y[1],1],pch=16,col='blue')
points(Shadow_MX[neigb_Y[2],2],Shadow_MX[neigb_Y[2],1],pch=16,col='blue')
points(Shadow_MX[neigb_Y[3],2],Shadow_MX[neigb_Y[3],1],pch=16,col='blue')
```


Similarly to simplex, we can use he cross-mapping from Y to X to estimate X.
The next figure presents the correlation between observed and estimated values of X.

```{r estimating X from Y}
lib<-lib <- c(1, NROW(Shadow_MXY))
block_lnlp_output <- block_lnlp(Shadow_MXY, lib = lib, pred = lib, columns = c("X",
 "Y","Y_1"), target_column = "X", stats_only = FALSE, first_column_time = TRUE)
observed <- block_lnlp_output$model_output[[1]]$obs
predicted <- block_lnlp_output$model_output[[1]]$pred

fit_YX<-lm(predicted ~ observed)
plot_range <- range(c(observed, predicted), na.rm = TRUE)
plot(observed, predicted, xlim = plot_range, ylim = plot_range, xlab = "Observed",
ylab = "Predicted")
abline(fit_YX$coefficients[1],fit_YX$coefficients[2])
legend(x = "bottomright", legend = paste('r =',round(cor(observed,predicted)*100)/100),inset = 0.02,col = 'black',lty = 1)



```

Do you expect to estimate Y from X?

```{r estimating Y from X}
lib<-lib <- c(1, NROW(Shadow_MXY))
block_lnlp_output <- block_lnlp(Shadow_MXY, lib = lib, pred = lib, columns = c("X",
 "X","X_1"), target_column = "Y", stats_only = FALSE, first_column_time = TRUE)
observed <- block_lnlp_output$model_output[[1]]$obs
predicted <- block_lnlp_output$model_output[[1]]$pred

fit_YX<-lm(predicted ~ observed)
plot_range <- range(c(observed, predicted), na.rm = TRUE)
plot(observed, predicted, xlim = plot_range, ylim = plot_range, xlab = "Observed",
ylab = "Predicted")
abline(fit_YX$coefficients[1],fit_YX$coefficients[2])
legend(x = "bottomleft", legend = paste('r =',round(cor(observed,predicted)*100)/100),inset = 0.02,col = 'black',lty = 1)


```


## What does it all mean?

Neighbors from a focal point in MY will be close to the concomitant neighbors for this same focal point in MX.
In another words, if X causes Y, the cross mapping skill from MY to MX is generally better than the cross mapping from MX to MY.
The causal variable (X) is contained in the dynamics of the effect (Y), therefore we can use the effect (Y) to estimate the cause (X).

Important to note here is the inverse relation between cross mapping and causality.
To better understand this relation, think about the dynamics of rain and vegetation.
We can roughly estimate how much have rained by loooking at the increase or decrease of vegetation.
Therefore, the cross mapping from Vegetation to Rain will give us good estimates of how much have rained.

## Convergent part of CCM

Convergence means that cross-mapped estimates improve in estimationskill with time-series length L (sample size used to construct a library).



```{r convergent}
  # cross map from X to Y
  X_xmap_Y<- ccm(XY, E = 2, lib_column = "X", target_column = "Y", lib_sizes = seq(10, 150, by = 10), num_samples = 100, random_libs = TRUE, replace = TRUE)
  # cross map from Y to X
  Y_xmap_X<- ccm(XY, E = 2, lib_column = "Y", target_column = "X", lib_sizes = seq(10, 150, by = 10), num_samples = 100, random_libs = TRUE, replace = TRUE)
  
  #mean values
  X_xmap_Y_means <- ccm_means(X_xmap_Y)
  Y_xmap_X_means <- ccm_means(Y_xmap_X)
  
  #plot graphs
  plot(X_xmap_Y_means$lib_size, pmax(0, X_xmap_Y_means$rho), type = "l", col = "red",main='Two Species', xlab = "Library Size", ylab = "Cross Map Skill (rho)", ylim = c(0,1))
  lines(Y_xmap_X_means$lib_size, pmax(0, Y_xmap_X_means$rho), col = "blue")
  legend(x = "topleft", legend = c("X_xmap_Y", "Y_xmap_X"), col = c("red", "blue"), cex=1.1,lwd=2, inset = 0.02)
  
```

With more data, the trajectories defining the attractor fill in, resulting in closer nearest neighbors and declining estimation error (a higher correlation coefficient) as L increases. Thus, CCM becomes a necessary condition for causation.


# Exercises

(1) What happens when there is a invertion in cause-effect realation? Change the model so the Y variable is causing changes in X.

(2) What if there is no interaction between X and Y?

(3) What about both variables interacting to each other?

(4) Identifying causal networks is important for effective policy and management recommendations on climate, epidemiology, financial regulation, and much else. 
In the following exercise, you should use CCM to identify causality between anchovy landings in California and Newport Pier sea-surface temperature.

```{r ex3}
data(sardine_anchovy_sst)
```

# Learn more

* Sugihara G. and R. M. May. 1990. Nonlinear forecasting as a way of distinguishing chaos 
from measurement error in time series. Nature 344:734–741.
* Sugihara G. 1994. Nonlinear forecasting for the classification of natural time series. 
Philosophical Transactions: Physical Sciences and Engineering 348:477–495.
* Anderson C. & Sugihara G. Simplex projection - Order out the chaos. http://deepeco.ucsd.edu/simplex/
* ["Simplex projection walkthrough"](http://opetchey.github.io/RREEBES/Sugihara_and_May_1990_Nature/Simplex_projection_walkthrough.html), a tutorial by Owen Petchey.


[^1]: This section is adapted from the tutorial ["Simplex projection walkthrough"](http://opetchey.github.io/RREEBES/Sugihara_and_May_1990_Nature/Simplex_projection_walkthrough.html), by Owen Petchey.

[^2]: The [next section](#sub2) shows some compealling evidence for this.

[^3]: For a full appraisal see: Deyle, E.R., Maher, M.C., Hernandez, R.D., Basu, S. and Sugihara, G., 2016. Global environmental drivers of influenza. Proceedings of the National Academy of Sciences, 113(46), pp.13081-13086.
